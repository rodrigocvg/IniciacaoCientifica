from pydoc import classname
from re import S
from typing import Dict
import cv2
import time
import math

from numpy import append
from numpy import array
import numpy as np



# DETECÇÃO = LISTA[0][0] = X1 / LISTA[0][1] = Y1 / LISTA[0][2] = x2 / LISTA[0][3] = Y2 //// 
def merge(Dic):
    novoD = {} #criar novo dicionario?
    limiar = 20
    for obj in Dic:
        print(obj)
        for x in range(0,len(Dic[obj])):
        #for x in Dic[obj]:
            print(Dic[obj][x])
            #print(x["box"]["box"])
            print(Dic[obj][x]["box"]["frame"])
            print(Dic[obj][x+1]["box"]["frame"]+1)
            #if Dic[obj][x]["box"]["frame"] == Dic[obj][x+1]["box"]["frame"]+1:

                

            #dist = menorDistancia4(Dic[obj][x],Dic[obj][x+1])
            #print(dist)
            #print (j["box"]["box"])
            #if dist <= limiar:
            #    novoD[obj].append(Dic[x])

    return novoD

    

# def merge(latu):  #merge(lof,latu)
   # lof = {box,class_names[classid]}
  #  limiar = 20
   # for (class_names[classid]) in latu:
    #    listaObj = buscarPorClassid(lof[1][0],class_names[classid])    # fazer buscaPorClassid
     #   if listaObj != [] :
     #       for i in range(i,listaObj):
     #           menorDist = menorDistancia(lof,latu)    #menorDistancia(lof.box, latu.box)
      #          if menorDist <= limiar:
       #             print("1")
                    #lof[1] = class_names[classid]
   # return lof

#lista
def menorDistancia4(obj1,obj2):
    Umx1 = obj1["box"]["box"][0]
    Umx2 = obj1["box"]["box"][2]
    Umy1 = obj1["box"]["box"][1]
    Umy2 = obj1["box"]["box"][3]
 

    Doisx1 = obj2["box"]["box"][0]
    Doisx2 = obj2["box"]["box"][2]
    Doisy1 = obj2["box"]["box"][1]
    Doisy2 = obj2["box"]["box"][3]

    CentroLofX = Umx2 - (Umx1/2)
    CentroLofY = Umy2 - (Umy1/2)


    CentroLatuX = Doisx2 - (Doisx1/2)
    CentroLatuY = Doisy2 - (Doisy1/2)


    dist = math.sqrt((CentroLofX - CentroLatuX)**2 + (CentroLofY - CentroLatuY)**2)

    return dist
    


# def buscaPorClassid(lof,class_names):
#DicDetcOfic[9][0]["box"]["box"][0] = x1
#Parametros = Dicionario, classid, i e j = objetos que serão comparados
def menorDistancia3(DicDetcOfic,classid,i,j): 
    Ob1x1 = DicDetcOfic[classid][i]["box"]["box"][0]
    Ob1x2 = DicDetcOfic[classid][i]["box"]["box"][2]
    Ob1y1 = DicDetcOfic[classid][i]["box"]["box"][1]
    Ob1y2 = DicDetcOfic[classid][i]["box"]["box"][3]

    Ob2x1 = DicDetcOfic[classid][j]["box"]["box"][0]
    Ob2x2 = DicDetcOfic[classid][j]["box"]["box"][2]
    Ob2y1 = DicDetcOfic[classid][j]["box"]["box"][1]
    Ob2y2 = DicDetcOfic[classid][j]["box"]["box"][3]
    CentroLofX = Ob1x2 - Ob1x1/2
    CentroLofY = Ob1y2 - Ob1y1/2


    CentroLatuX = Ob2x2 - Ob2x1/2
    CentroLatuY = Ob2y2 - Ob2y1/2

    dist = math.sqrt((CentroLofX - CentroLatuX)**2 + (CentroLofY - CentroLatuY)**2)

    return dist


#mudar menorDistancia para Dicionario

def menorDistancia(lof,latu):   
    #retornar de quem é a menor distancia tb
    #CentroLofX = x2 - x1/2 
   CentroLofX = lof[0][2] - (lof[0][0]/2)
    #CentroLofY= y2 - y1/2
   CentroLofY = lof[0][3] - (lof[0][1]/2)
    #CentroLatuY = x2 -x1/2
   CentroLatuX = latu[0][2] - (latu[0][0]/2)
    #CentroLofY= y2 - y1/2
   CentroLatuY = latu[0][3] - (latu[0][1]/2)
    

   dist = math.sqrt((CentroLofX - CentroLatuX)**2 + (CentroLofY - CentroLatuY)**2)

   #dist = math.sqrt((lof[0][0] - lof[0][1])^2 + (latu[0][0] - latu[0][1])^2)   # provavel errado
   return dist


def menorDistancia2(lof,latu):
    x1lof = lof[0][0] 
    y1lof = lof[0][1]
    x2lof = lof[0][2]
    y2lof = lof[0][3]
    CentroLof = math.sqrt((x1lof - x2lof)^2 + (y1lof - y2lof)^2)
    x1latu = latu[0][0] 
    y1latu= latu[0][1]
    x2latu= latu[0][2]
    y2latu = latu[0][3]
    CentroLatu = math.sqrt((x1latu - x2latu)^2 + (y1latu - y2latu)^2)
    dist = CentroLof - CentroLatu
    return dist

 

#dicionario = chave = classnames[class id]
#             valor = listaObj




#Cores
COLORS = [(0,255,255), (255,255,0), (0,255,0), (255,0,0)]

#Carrega as classes do coco.names
class_names = []
with open("coco.names.txt","r") as f:
    class_names = [cname.strip() for cname in f.readlines()]

#Carrega o vídeo usando OpenCv
cap = cv2.VideoCapture("vid.mp4")

#Carregando os weights da rede neural 
net = cv2.dnn.readNet("yolov4-tiny.weights","yolov4-tiny.cfg.txt")

#Setar parametros da rede neural
model = cv2.dnn_DetectionModel(net)
model.setInputParams(size=(416,416),scale=1/255)
var = 1
frameI = 1


ListaDetcAtual = []
DicDetcOfic = {}
DicValor = {}
Dicio = {}
dicFrame = {}
cont = 0
#Capturando os frames com OpenCv, loop infinito
while True:

    # Captura dos frames
    _, frame = cap.read()
    #print(i)
    
    dicFrame[frameI] = []
    
    #Começo da contagem dos segundos(FPS)
    começo = time.time()

    #Detectando com model.detect
    classes,scores,boxes = model.detect(frame, 0.1, 0.2)

    #Fim da contagem 
    fim = time.time()
    
    # Laço para percorrer todas as detecções
    for(classid,score,box) in zip(classes,scores,boxes):

        #Gerando uma cor para a classe
        color = COLORS[int(classid) % len(COLORS)]
        
        #String para mostrar nome da classe e seu score (porcentagem de eficácia da detecção)
        text = f"{class_names[classid]} : {[score]}"
        
        #Desenhando o retângulo da classe
        cv2.rectangle(frame,box,color,2)

        #Escreve o nome da classe em cima da box
        cv2.putText(frame,text,(box[0], box[1]-15), cv2.QT_FONT_NORMAL,0.5,color,2)

        #print(i,box, class_names[classid])
        # var = var + 1
        #ListaDetcAtual = [box, class_names[classid]]
        #ListaDetecOfic = merge(ListaDetecAtual)
        #print(i, ListadetcAtual) 
        #DicDetcOfic = {classid+1:ListaDetcOfic}  #DicDetcOfc = {class_names[classid]:ListadetcOfc}
        #valor = DicDetcOfic[classid+1]
        #if not classid+1 in DicDetcOfic:
            #DicDetcOfic[classid+1] = [{class_names[classid],box}] 
           # DicDetcOfic[classid+1] = []
        #if not frameI in dicFrame:
        

        dicFrame[frameI].append({"box":box}) #Criação do dicionário dos frames

        cont+= 1
        idObj = class_names[classid] + str(cont)

        if not idObj in DicValor:
            DicValor[idObj] = []
       

        #DicValor.update(dicFrame)
        #DicValor[idObj] = dicFrame
        DicValor[idObj].append({"DicFrame":dicFrame})
        if not classid+1 in Dicio:
            Dicio[classid+1] = []


        Dicio[classid+1].append({"DicValor":DicValor})
    
        #else:
        #DicDetcOfic[classid+1].append({class_names[classid],box})
        # fazendo append de todas as detecções e colocando em apenas um dicionário
        #DicDetcOfic[classid+1].append({"classname": class_names[classid], "box": box, "frame":i})
        #DicDetcOfic[classid+1].append({"classname": class_names[classid], "box": {"frame":i,"box":box}})
        #ListaDetcAtual.append([box,class_names[classid]])   
        # DicDetcOfic[9][0]["classname"] = boat / 9 = key, 0 = primeira detecção
        #print(ListadetcAtual[0][0])
        
        var = var + 1
    
    
    #Calculando o FPS
    fps_text = f"FPS: {round((1.5/(fim - começo)),2)}"

    #Colocando FPS na tela
    cv2.putText(frame,fps_text, (0,25), cv2.QT_FONT_NORMAL, 1,(0,0,0), 5)
    cv2.putText(frame,fps_text, (0,25), cv2.QT_FONT_NORMAL, 1,(0,255,0), 3)

    #Mostrando imagem
    cv2.imshow("teste", frame)

    #Programa finaliza no 'ESC'
    if cv2.waitKey(1) == 27:
        #print(DicDetcOfic)
        #print(DicDetcOfic[9][0]["classname"])
        #print(ListaDetcAtual)
        #print(DicDetcOfic[9][0]["box"]["box"][0])
        #print(menorDistancia3(DicDetcOfic,9,0,1))
        #print(menorDistancia4(DicDetcOfic[9][0],DicDetcOfic[9][1]))
        #print(merge(DicDetcOfic)) 
        print(dicFrame)
        
        


        #for j in range(len(ListaDetcAtual)):
            #print("Distancia entre os objetos", 0, "(",ListaDetcAtual[j][1],") e", j+1, "(",ListaDetcAtual[j+1][1],")" )
            #print(menorDistancia(ListaDetcAtual[0],ListaDetcAtual[j+1]))
            


        #print(menorDistancia(ListaDetcAtual[0],ListaDetcAtual[1]))
        break
    frameI = frameI+1



    
    
    
   

#Destruir todas janelas e fechar programa
cap.release()
cap.destroyAllWindows()
